*Люй Цюхуэй P3403c

* asm | acc | neum | hw | instr | binary | trap | mem | pstr | prob5 | spi

## asm Языки программирования

* Сам язык нечувствителен к регистру. За исключением объявлений символов. Например ld #1 равно LD #1
* Первая функция объзательно _start, которая является входом.
* Код выполняется последовательно. Операции:

  - `ld аргумент` -- нагрузка. Его функция — загрузка данных из памяти в регистр

  - `st аргумент` -- удалить. Выгрузить значение из регистра в память

  - `add аргумент` -- Добавляет указанное значение в регистр

  - `sub аргумент` -- Удаляет указанное значение из реестра

  - `mul аргумент` -- Умножить регистр на указанное значение

  - `div аргумент` -- Делит регистр на указанное

  - `cmp аргумент` -- Сравнивает значение регистра с указанным значением и устанавливает значение состояния.

  - `jmp аргумент` -- Безоговорочно переходит к целевому адресу, указанному инструкцией, и начинает выполнение с этого адреса. Целевой адрес может быть получен непосредственно из инструкции или из регистра или памяти, указанных в инструкции.

  - `jz аргумент` -- Простая инструкция условного перевода – передача равенства

  - `js аргумент` -- Одна инструкция условной передачи — результат передачи предыдущей операции представляет собой отрицательное число. 

  - `jnz аргумент` -- Простая инструкция условной передачи — неравная передача (аналогично JNE）
  
  - `hlt` -- Инструкция переводит процессор в остановленное состояние.
  
  - `push` -- Вставьте в стек. Поместите слово данных из регистра или регистра сегмента в стек.
  
  - `pop` --  Выйдите из стека. Поместить верхний элемент стека в регистр
  
  - `call аргумент` -- вызвать функцию
  
  - `ret` -- выйти из функции
  
  - `inv` -- получить обратное число аккумулятора
  
* Все после ";" считается комментарией в строке

* Поддерживает кордирование символа. Символы сохраняются в памяти как число:

```

' ':0, 'a':1, 'b':2, 'c':3, 'd':4, 'e':5, 'f':6, 'g':7, 'h':8, 'i':9, 'j':10,
'k':11, 'l':12, 'm':13, 'n':14, 'o':15, 'p':16, 'q':17, 'r':18, 's':19, 't':20, 'u':21,'v':22, 'w':23, 'x':24, 'y':25, 'z':26, 'A':27, 'B':28, 'C':29, 'D':30, 'E':31, 'F':32,'G':33, 'H':34, 'I':35, 'J':36, 'K':37, 'L':38, 'M':39, 'N':40, 'O':41, 'P':42, 'Q':43,'R':44, 'S':45, 'T':46, 'U':47, 'V':48, 'W':49, 'X':50, 'Y':51, 'Z':52, '':53, '0':54,'1':55, '2':56, '3':57, '4':58, '5':59, '6':60, '7':61, '8':62, '9':63, '!':64, ',':65,'.':66, '-':67, '*':68, '?':69, '+':70, '/':71, '@':72, '\0':73, '\n':74

```

* Управляющие метки:

 - 'section .data' - метка, сигнализирующая о начале области данных. После нее можно объявлять переменные, но нельзя писать код.
 - 'section .text' - метка, сигнализирующая о начале код


* Функция и метка:

  * Функцию так определим: '<Называние функции>:'
  * Метку так опредлим: '.<Называние метки>:'

  Разница в том что метка начинается с ".". И когда мы хотим переходить в какую-то метку, то нужно так использовать мекту:

  jmp .label_name

* Адресация(формат аргумента):

 * Прямая: если аргумент просто какое-то число, то он считается адрес. То есть, ld 29 - это значит загрузить значение в 30-ой ячейка в аккумулятор
  * Просто значение: если в аргументе есть  '#' и после него получается одно число, то аргумент считается значение. То есть, ld #29 - это загрузить 29 в аккумулятор
  * Переменные: если аргумент является переменной, которая определена в секции данных, то он считает адрес переменной.
  * Символ: кодируется в число по таблице символов. Например, ld 'A' = ld #27

* Значения состояния:

  * N = 1
  * Z = 2
  * V = 4
  * C = 8

* Переменные:

  * Определённы таким образом: '<Называние: Значение>'. Значение может быть числом или строкой. Если строкой, то она будет обладать столько количеств ячейк, сколько количеств её символов. 


## Организация памяти

Память команд и данных одна.

Память является списком, который состоит из ячейк. Ячейк реализуется классом Cell. ячейке сохраняет

* Или число – то есть данные. Машинные биты - 32 бита. **Ячейка содержит только один символ. Этот символ также принимает числовую форму в соответствии с таблицей символов, определенной в ISA**.
* Или инструкция, которая представляется в виде класса - Instruction.**В объекте класса instruction сохраняет тип инструкции и аргумент**


Стек одельно создан.

Последное **1/4** части является IO портами, которые только служит для IO.

### Система команд

* Машинное слово -- 32 бит, знаковое.
* Архитектура - Фон Неймановская архитектура
* Регистры:

* IP - счётчик
  * AC - 
    * аккумулятор
    * взаймодействует с стеком
    * сохраняет результат любой фунции
    * сохраняет результат любой математической операции
  * BR - как буфер, где временно сохраняют данные. Например, он применяется для сохранения результата фукции в инструкции ret. 
  * AR - указывающий адрес ячейки, с которой взаймодействуют, регистр. Тоже указывает? 'адрес' стека.
  * PS - NZVC. 
  * SP - указатель стека.


## кодирование инструкций

Машинный код хранится в формате CSV.

Вся программа разделена на 4 части. отличающиеся указанными тегами,

- Первая часть инструкций перед тегом FUNCTION представляет собой набор инструкций. Каждая строка содержания инструкции разделена на три столбца со знаком " ":
   - Первый столбец - это индекс инструкции.
   - Второй столбец - инструкции
   - Параметры третьего столбца (если есть)
- Вторая часть — это функция. Содержимое после FUNCTION и перед LABEL — это выполняемая функция. Каждая строка содержимого функции разделена на два столбца со знаком «:»:
   - Первый столбец - это имя
   - Второй столбец - индекс инструкции
– Третья часть — это метка. Содержимое после LABEL и перед VARIABLE — это метка. Каждая строка содержимого метки разделена на три столбца со знаком «:»:
   - Первый столбец - это имя функции
   - Второй столбец — название ярлыка.
   -Третий столбец — индекс инструкций.
— Четвертая часть — это переменная, а содержимое после тега VARIABLE — это переменная. Переменные разделены на три столбца со знаком «:»:
   - Первый столбец — это имя переменной
   - Второй столбец - значение
   - Третий столбец - длина строки (если есть)

Пример:

```
0 LD 'H' 
1 ST OUTPUT 
2 LD 'e' 
3 ST OUTPUT 
4 LD 'l' 
5 ST OUTPUT 
6 LD 'l' 
7 ST OUTPUT 
8 LD 'o' 
9 ST OUTPUT 
10 LD ',' 
11 ST OUTPUT 
12 LD 'w' 
13 ST OUTPUT 
14 LD 'o' 
15 ST OUTPUT 
16 LD 'r' 
17 ST OUTPUT 
18 LD 'l' 
19 ST OUTPUT 
20 LD 'd' 
21 ST OUTPUT 
22 HLT 
FUNCTION
_START:0
LABEL
_START:.LOOP:0
VARIABLE

```


## Транслятор


Командной строки: `translator.py <input_file> <target_file>"`


Позволяет поддерживать основные debug:

* Нельзя определять две переменной однин имени
* Нельзя использовать "Input" или "Output" как называния переменных
* Проверяет правильно ли пользователь опредлять аргумент. Например, определять аргумент инструкции, у которой нет аргумента.
* Проверяет формат переменной.
* Информация ощибок будет указывать места ошибок.

Этапы трансляции (функция `translate`):


1. Проверка метка section .DATA
2. Чтение переменных и сохраняет их в славарь variable
3. Проверка метка section .TEXT
4. Чтение код
   * Если строка является метка, то сохраняет её место, включающиую её функцию и называние в славарь label_in_fun.
   * Если строка является фунцию, то сохраняет её место и называние в славарь function_point
   * Если строка является инструкцией, то сохраняет его место, тип и аргумент в строку result
5. Когда читает строку, автоматически игнорирует комментарию
6. Перед любой обработкой из 1-4, строки будут преобразованы в верхний регистр.
7. Генерация выходной файл на основе result, variable, label_in_fun и function_point.
## Компьютерное моделирование

Выполнение заказа: `machine.py <target_file> <inputfile>".`


Такт(Hardwired):

* Операции на одном объекте не выполняются в одном такте.
* Операции на разных объектах выполняются в одном такте. 


Реализация алгоритма:
* problem5： /asm/problem5.asm
* cat     : /asm/cat.asm
* hello   : /asm/hello.asm

## Ручное тестирование:

* Машинное тестирование：test_machine.py
* Тест перевода：test_translator.py

## Автоматическое тестирование：
  GIT-адрес：https://github.com/Daliyalv/Machine.git
  После отправки кода (master ветвь) автоматически запустится обнаружение приложения Python, а файлы test_machine.py и test_translator.py будут автоматически выполнены, и обнаружение пройдет успешно.
